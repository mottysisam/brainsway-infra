// Generated by Claude on 2025-08-14 for: Internal Router Lambda Function
// Enhanced with parameter flattening and robust error handling

const AWS = require('aws-sdk');
const lambda = new AWS.Lambda({ region: process.env.AWS_DEFAULT_REGION || 'us-east-2' });

// Function mapping from environment variables
const FUNCTION_MAP = JSON.parse(process.env.FUNCTION_MAP || '{}');
const CACHE_TTL_MS = parseInt(process.env.CACHE_TTL_MS || '300000'); // 5 minutes default
const ENABLE_DIRECT_INVOCATION = process.env.ENABLE_DIRECT_INVOCATION === 'true';

// Simple in-memory cache
const cache = new Map();

exports.handler = async (event, context) => {
    console.log('Internal Router Handler - Event:', JSON.stringify(event, null, 2));
    console.log('Environment:', process.env.ENVIRONMENT);
    console.log('Available Functions:', Object.keys(FUNCTION_MAP));

    try {
        // Extract function name from path
        const pathParameters = event.pathParameters || {};
        const functionName = pathParameters.functionName || pathParameters.proxy;
        
        if (!functionName) {
            return {
                statusCode: 400,
                headers: {
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*',
                    'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token',
                    'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS'
                },
                body: JSON.stringify({
                    error: 'Function name is required',
                    message: 'Path must include function name: /lambda/function/{functionName}',
                    availableFunctions: Object.keys(FUNCTION_MAP)
                })
            };
        }

        // Get function ARN from mapping
        const targetFunctionArn = FUNCTION_MAP[functionName];
        if (!targetFunctionArn) {
            return {
                statusCode: 404,
                headers: {
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*'
                },
                body: JSON.stringify({
                    error: 'Function not found',
                    functionName: functionName,
                    availableFunctions: Object.keys(FUNCTION_MAP)
                })
            };
        }

        // Prepare payload for target function
        let payload = {};
        
        // Include query parameters
        if (event.queryStringParameters) {
            payload.queryStringParameters = event.queryStringParameters;
        }
        
        // Include body (parse JSON if present)
        if (event.body) {
            try {
                payload.body = JSON.parse(event.body);
            } catch (e) {
                payload.body = event.body;
            }
        }
        
        // Include headers (excluding auth headers for security)
        if (event.headers) {
            const filteredHeaders = {};
            Object.keys(event.headers).forEach(key => {
                if (!key.toLowerCase().includes('authorization') && 
                    !key.toLowerCase().includes('x-api-key')) {
                    filteredHeaders[key] = event.headers[key];
                }
            });
            payload.headers = filteredHeaders;
        }

        // Include HTTP method and path info
        payload.httpMethod = event.httpMethod || 'GET';
        payload.path = event.path;
        payload.pathParameters = event.pathParameters;

        // Check cache if enabled and method is GET
        const cacheKey = `${functionName}-${JSON.stringify(payload)}`;
        if (event.httpMethod === 'GET' && cache.has(cacheKey)) {
            const cached = cache.get(cacheKey);
            if (Date.now() - cached.timestamp < CACHE_TTL_MS) {
                console.log('Returning cached response for:', functionName);
                return {
                    ...cached.response,
                    headers: {
                        ...cached.response.headers,
                        'X-Cache': 'HIT',
                        'X-Cache-Age': Math.floor((Date.now() - cached.timestamp) / 1000)
                    }
                };
            } else {
                cache.delete(cacheKey);
            }
        }

        // Invoke target Lambda function
        console.log('Invoking function:', targetFunctionArn);
        console.log('Payload:', JSON.stringify(payload, null, 2));

        const params = {
            FunctionName: targetFunctionArn,
            InvocationType: 'RequestResponse',
            Payload: JSON.stringify(payload)
        };

        const result = await lambda.invoke(params).promise();
        
        let response;
        if (result.Payload) {
            try {
                response = JSON.parse(result.Payload);
            } catch (e) {
                console.error('Failed to parse Lambda response:', e);
                response = {
                    statusCode: 500,
                    body: JSON.stringify({
                        error: 'Invalid response from target function',
                        details: result.Payload.toString()
                    })
                };
            }
        } else {
            response = {
                statusCode: 500,
                body: JSON.stringify({
                    error: 'No response from target function'
                })
            };
        }

        // Handle Lambda execution errors
        if (result.FunctionError) {
            console.error('Lambda execution error:', result.FunctionError);
            return {
                statusCode: 500,
                headers: {
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*'
                },
                body: JSON.stringify({
                    error: 'Target function execution failed',
                    functionName: functionName,
                    errorType: result.FunctionError,
                    details: response
                })
            };
        }

        // Cache successful GET responses
        if (event.httpMethod === 'GET' && response.statusCode < 400) {
            cache.set(cacheKey, {
                response: response,
                timestamp: Date.now()
            });
        }

        // Ensure proper CORS headers
        const finalResponse = {
            ...response,
            headers: {
                'Content-Type': 'application/json',
                'Access-Control-Allow-Origin': '*',
                'Access-Control-Allow-Headers': 'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token',
                'Access-Control-Allow-Methods': 'GET,POST,PUT,DELETE,OPTIONS',
                'X-Cache': 'MISS',
                ...response.headers
            }
        };

        console.log('Final response:', JSON.stringify(finalResponse, null, 2));
        return finalResponse;

    } catch (error) {
        console.error('Internal Router Error:', error);
        
        return {
            statusCode: 500,
            headers: {
                'Content-Type': 'application/json',
                'Access-Control-Allow-Origin': '*'
            },
            body: JSON.stringify({
                error: 'Internal server error',
                message: error.message,
                requestId: context.awsRequestId
            })
        };
    }
};