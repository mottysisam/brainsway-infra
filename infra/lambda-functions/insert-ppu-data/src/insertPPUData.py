# Generated by Claude on 2025-08-14 for: PPU Data Insert Lambda Function
# Enhanced with error handling and body parsing

import json
import os
import logging
import traceback
from datetime import datetime
import boto3
import psycopg2
from psycopg2.extras import RealDictCursor

# Configure logging
logger = logging.getLogger()
logger.setLevel(logging.INFO)

# Environment variables
DB_ENDPOINT = os.environ.get('DB_ENDPOINT')
DB_PORT = os.environ.get('DB_PORT', '5432')
DB_USER = os.environ.get('DB_USER')
DB_PASSWORD = os.environ.get('DB_PASSWORD')
DB_NAME = os.environ.get('DB_NAME')
DYNAMODB_TABLE = os.environ.get('DYNAMODB_TABLE')
ENVIRONMENT = os.environ.get('ENVIRONMENT', 'dev')

# AWS clients
dynamodb = boto3.resource('dynamodb')

def get_db_connection():
    """Create database connection with error handling"""
    try:
        connection = psycopg2.connect(
            host=DB_ENDPOINT,
            port=DB_PORT,
            database=DB_NAME,
            user=DB_USER,
            password=DB_PASSWORD,
            cursor_factory=RealDictCursor
        )
        return connection
    except Exception as e:
        logger.error(f"Database connection failed: {str(e)}")
        raise

def parse_request_body(event):
    """Parse request body from various event formats"""
    try:
        # Direct body from API Gateway
        if 'body' in event:
            if isinstance(event['body'], dict):
                return event['body']
            elif isinstance(event['body'], str):
                return json.loads(event['body'])
        
        # Direct event data (for testing)
        if 'patient_id' in event or 'treatment_data' in event:
            return event
            
        # Default empty data
        return {}
        
    except json.JSONDecodeError as e:
        logger.error(f"Failed to parse request body: {str(e)}")
        raise ValueError("Invalid JSON in request body")

def validate_ppu_data(data):
    """Validate PPU data structure"""
    required_fields = ['patient_id', 'treatment_data']
    
    for field in required_fields:
        if field not in data:
            raise ValueError(f"Missing required field: {field}")
    
    # Validate treatment_data structure
    treatment_data = data['treatment_data']
    if not isinstance(treatment_data, dict):
        raise ValueError("treatment_data must be an object")
    
    # Add timestamp if not present
    if 'timestamp' not in treatment_data:
        treatment_data['timestamp'] = datetime.utcnow().isoformat()
    
    return data

def insert_ppu_data_to_db(data):
    """Insert PPU data into PostgreSQL database"""
    connection = None
    try:
        connection = get_db_connection()
        cursor = connection.cursor()
        
        # Prepare the data for insertion
        patient_id = data['patient_id']
        treatment_data = data['treatment_data']
        timestamp = treatment_data.get('timestamp', datetime.utcnow().isoformat())
        
        # Insert query (adjust table/column names as needed)
        insert_query = """
            INSERT INTO ppu_treatments (
                patient_id, 
                treatment_data, 
                timestamp,
                environment,
                created_at
            ) VALUES (%s, %s, %s, %s, %s)
            RETURNING id;
        """
        
        cursor.execute(insert_query, (
            patient_id,
            json.dumps(treatment_data),
            timestamp,
            ENVIRONMENT,
            datetime.utcnow()
        ))
        
        result = cursor.fetchone()
        connection.commit()
        
        logger.info(f"Successfully inserted PPU data for patient {patient_id}")
        return result['id'] if result else None
        
    except Exception as e:
        if connection:
            connection.rollback()
        logger.error(f"Database insertion failed: {str(e)}")
        raise
    finally:
        if connection:
            connection.close()

def log_to_dynamodb(event_data):
    """Log event to DynamoDB for audit trail"""
    if not DYNAMODB_TABLE:
        logger.warning("DynamoDB table not configured, skipping audit log")
        return
    
    try:
        table = dynamodb.Table(DYNAMODB_TABLE)
        
        log_entry = {
            'event_id': f"ppu-{datetime.utcnow().strftime('%Y%m%d-%H%M%S')}-{os.urandom(4).hex()}",
            'event_type': 'ppu_data_insert',
            'patient_id': event_data.get('patient_id', 'unknown'),
            'timestamp': datetime.utcnow().isoformat(),
            'environment': ENVIRONMENT,
            'success': True,
            'metadata': {
                'function_name': 'insert-ppu-data',
                'aws_request_id': event_data.get('aws_request_id', 'unknown')
            }
        }
        
        table.put_item(Item=log_entry)
        logger.info(f"Logged event to DynamoDB: {log_entry['event_id']}")
        
    except Exception as e:
        logger.error(f"Failed to log to DynamoDB: {str(e)}")
        # Don't fail the main operation for logging issues

def handler(event, context):
    """Main Lambda handler function"""
    logger.info(f"PPU Data Insert Handler - Event: {json.dumps(event, default=str)}")
    
    try:
        # Parse request body
        request_data = parse_request_body(event)
        logger.info(f"Parsed request data: {json.dumps(request_data, default=str)}")
        
        # Handle test mode
        if request_data.get('test', False):
            logger.info("Test mode detected, skipping actual database insertion")
            return {
                'statusCode': 200,
                'headers': {
                    'Content-Type': 'application/json',
                    'Access-Control-Allow-Origin': '*'
                },
                'body': json.dumps({
                    'success': True,
                    'message': 'Test mode - no data inserted',
                    'environment': ENVIRONMENT,
                    'function': 'insert-ppu-data'
                })
            }
        
        # Validate data
        validated_data = validate_ppu_data(request_data)
        
        # Insert to database
        record_id = insert_ppu_data_to_db(validated_data)
        
        # Log to DynamoDB
        audit_data = {
            **validated_data,
            'record_id': record_id,
            'aws_request_id': context.aws_request_id
        }
        log_to_dynamodb(audit_data)
        
        # Return success response
        response = {
            'statusCode': 200,
            'headers': {
                'Content-Type': 'application/json',
                'Access-Control-Allow-Origin': '*'
            },
            'body': json.dumps({
                'success': True,
                'message': 'PPU data inserted successfully',
                'record_id': record_id,
                'patient_id': validated_data['patient_id'],
                'timestamp': validated_data['treatment_data']['timestamp'],
                'environment': ENVIRONMENT
            })
        }
        
        logger.info(f"Success response: {json.dumps(response, default=str)}")
        return response
        
    except ValueError as e:
        logger.error(f"Validation error: {str(e)}")
        return {
            'statusCode': 400,
            'headers': {
                'Content-Type': 'application/json',
                'Access-Control-Allow-Origin': '*'
            },
            'body': json.dumps({
                'success': False,
                'error': 'Validation error',
                'message': str(e),
                'environment': ENVIRONMENT
            })
        }
        
    except Exception as e:
        logger.error(f"Unexpected error: {str(e)}")
        logger.error(f"Traceback: {traceback.format_exc()}")
        return {
            'statusCode': 500,
            'headers': {
                'Content-Type': 'application/json',
                'Access-Control-Allow-Origin': '*'
            },
            'body': json.dumps({
                'success': False,
                'error': 'Internal server error',
                'message': str(e),
                'environment': ENVIRONMENT,
                'request_id': context.aws_request_id if context else 'unknown'
            })
        }