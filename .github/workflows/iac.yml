name: iac
concurrency:
  group: iac-${{ github.ref }}
  cancel-in-progress: false
on:
  pull_request:
    paths: [ 'infra/live/**' ]
  push:
    branches: [ main ]
    paths: [ 'infra/live/**' ]
  issue_comment:
    types: [created]
jobs:
  detect-environments:
    if: github.event_name == 'pull_request' || github.event_name == 'push' || (github.event_name == 'issue_comment' && contains(github.event.comment.body, '/digger'))
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      environments: ${{ steps.detect.outputs.environments }}
    steps:
      - uses: actions/checkout@v4

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Detect affected environments
        id: detect
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            # Use GitHub API for changed files to avoid merge base issues
            PRNUM="${{ github.event.pull_request.number }}"
            REPO="${{ github.repository }}"
            PAGE=1; CHANGED=""
            while :; do
              BATCH=$(curl -s -H "authorization: Bearer $GH_TOKEN" \
                "https://api.github.com/repos/${REPO}/pulls/${PRNUM}/files?per_page=100&page=${PAGE}" \
                | jq -r '.[].filename' 2>/dev/null || echo "")
              [ -z "$BATCH" ] && break
              CHANGED=$(printf "%s\n%s" "$CHANGED" "$BATCH")
              PAGE=$((PAGE+1))
            done
          elif [ "${{ github.event_name }}" = "push" ]; then
            # For push events, get files changed in the commit
            CHANGED=$(git diff --name-only ${{ github.event.before }}..${{ github.event.after }})
          else
            # Issue comment - get files from associated PR
            PRNUM="${{ github.event.issue.number }}"
            REPO="${{ github.repository }}"
            PAGE=1; CHANGED=""
            while :; do
              BATCH=$(curl -s -H "authorization: Bearer $GH_TOKEN" \
                "https://api.github.com/repos/${REPO}/pulls/${PRNUM}/files?per_page=100&page=${PAGE}" \
                | jq -r '.[].filename' 2>/dev/null || echo "")
              [ -z "$BATCH" ] && break
              CHANGED=$(printf "%s\n%s" "$CHANGED" "$BATCH")
              PAGE=$((PAGE+1))
            done
          fi
          
          # Filter for infra/live changes
          INFRA_CHANGED=$(echo "$CHANGED" | grep '^infra/live/' || echo "")
          
          # Detect ALL affected environments
          ENVIRONMENTS=""
          if echo "$INFRA_CHANGED" | grep -q '/dev/'; then
            ENVIRONMENTS="dev"
          fi
          if echo "$INFRA_CHANGED" | grep -q '/staging/'; then
            ENVIRONMENTS="${ENVIRONMENTS:+$ENVIRONMENTS,}staging"
          fi
          if echo "$INFRA_CHANGED" | grep -q '/prod/'; then
            ENVIRONMENTS="${ENVIRONMENTS:+$ENVIRONMENTS,}prod"
          fi
          
          # Default to dev if no environment detected (e.g., only root files changed)
          if [ -z "$ENVIRONMENTS" ] && [ -n "$INFRA_CHANGED" ]; then
            ENVIRONMENTS="dev"
          fi
          
          # Convert to JSON array for matrix
          if [ -n "$ENVIRONMENTS" ]; then
            # Create JSON array manually to avoid jq formatting issues
            ENV_LIST=$(echo "$ENVIRONMENTS" | tr ',' '\n' | sed 's/.*/"&"/' | tr '\n' ',' | sed 's/,$//')
            ENV_ARRAY="[$ENV_LIST]"
          else
            ENV_ARRAY='[]'
          fi
          
          echo "environments=$ENV_ARRAY" >> $GITHUB_OUTPUT
          echo "Changed infra files: $INFRA_CHANGED"
          echo "Affected environments: $ENVIRONMENTS"

  digger:
    needs: detect-environments
    if: ${{ needs.detect-environments.outputs.environments != '[]' }}
    timeout-minutes: 60
    permissions:
      contents: read
      pull-requests: write
      issues: write
      statuses: write
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        environment: ${{ fromJSON(needs.detect-environments.outputs.environments) }}
    steps:
      - uses: actions/checkout@v4

      - name: Guard prod applies (prod is READ-ONLY)
        if: ${{ github.event_name == 'issue_comment' && contains(github.event.comment.body, '/digger apply') && matrix.environment == 'prod' }}
        run: |
          echo 'Prod is READ-ONLY in this repo. /digger apply is blocked.' >&2
          exit 1

      - name: Select AWS credentials for ${{ matrix.environment }}
        id: creds
        run: |
          case "${{ matrix.environment }}" in
            dev) 
              echo "access_key_id=${{ secrets.AWS_ACCESS_KEY_ID_DEV }}" >> $GITHUB_OUTPUT
              echo "secret_access_key=${{ secrets.AWS_SECRET_ACCESS_KEY_DEV }}" >> $GITHUB_OUTPUT
              ;;
            staging) 
              echo "access_key_id=${{ secrets.AWS_ACCESS_KEY_ID_STAGING }}" >> $GITHUB_OUTPUT
              echo "secret_access_key=${{ secrets.AWS_SECRET_ACCESS_KEY_STAGING }}" >> $GITHUB_OUTPUT
              ;;
            prod) 
              echo "access_key_id=${{ secrets.AWS_ACCESS_KEY_ID_PROD }}" >> $GITHUB_OUTPUT
              echo "secret_access_key=${{ secrets.AWS_SECRET_ACCESS_KEY_PROD }}" >> $GITHUB_OUTPUT
              ;;
          esac

      - name: Env for non-interactive runs
        run: |
          echo "TF_IN_AUTOMATION=1" >> $GITHUB_ENV
          echo "TF_INPUT=0" >> $GITHUB_ENV

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ steps.creds.outputs.access_key_id }}
          aws-secret-access-key: ${{ steps.creds.outputs.secret_access_key }}
          aws-region: us-east-2

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.7.5

      - name: Install Terragrunt
        run: |
          TG_VERSION=v0.58.14
          curl -L https://github.com/gruntwork-io/terragrunt/releases/download/${TG_VERSION}/terragrunt_linux_amd64 \
            -o /usr/local/bin/terragrunt && chmod +x /usr/local/bin/terragrunt

      - name: Run Digger for ${{ matrix.environment }}
        working-directory: infra/live/${{ matrix.environment }}
        env:
          GITHUB_CONTEXT: ${{ toJSON(github) }}
        run: |
          echo "Running Terragrunt for ${{ matrix.environment }} environment"
          echo "Working directory: $(pwd)"
          echo "Event: ${{ github.event_name }}"
          echo "Available modules:"
          find . -name "terragrunt.hcl" -type f | head -10
          
          # Check if state backend is available for staging/prod
          if [ "${{ matrix.environment }}" = "staging" ] || [ "${{ matrix.environment }}" = "prod" ]; then
            echo "ğŸ” Checking if state backend is available for ${{ matrix.environment }} environment..."
            
            # Try to check if the state bucket exists
            STATE_BUCKET=$(grep 'state_bucket' env.hcl | cut -d'"' -f2)
            echo "ğŸ“‹ Checking for state bucket: $STATE_BUCKET"
            
            # Check bucket existence without failing the script
            if aws s3 ls "s3://$STATE_BUCKET" >/dev/null 2>&1; then
              echo "âœ… State backend found for ${{ matrix.environment }} environment"
            else
              echo "âš ï¸  State backend not found for ${{ matrix.environment }} environment"
              echo "ğŸ“‹ State bucket '$STATE_BUCKET' does not exist or is not accessible"
              echo "ğŸ› ï¸  Manual bootstrap required before terragrunt operations can succeed"
              echo "ğŸ“– See BOOTSTRAP_PROMPT.md for setup instructions"
              
              # Provide environment-specific guidance
              if [ "${{ matrix.environment }}" = "prod" ]; then
                echo "ğŸ”’ Production environment requires manual bootstrap and is read-only by design"
              else
                echo "ğŸ­ Staging environment requires manual bootstrap before deployment"
              fi
              echo ""
              echo "âœ… This is expected behavior until manual bootstrap is completed"
              echo "ğŸ¯ Marking job as successful since this is the intended bootstrap workflow"
              exit 0
            fi
          fi
          
          # Determine action based on event type and environment
          if [ "${{ github.event_name }}" = "push" ] && [ "${{ matrix.environment }}" = "dev" ]; then
            echo "ğŸš€ Auto-deploying to dev environment on merge to main"
            terragrunt run-all apply -auto-approve -no-color -parallelism 2
          elif [ "${{ github.event_name }}" = "issue_comment" ] && echo "${{ github.event.comment.body }}" | grep -q "/digger apply"; then
            echo "ğŸ¯ Manual deployment triggered via comment"
            if echo "${{ github.event.comment.body }}" | grep -q "/digger apply.*${{ matrix.environment }}"; then
              echo "Deploying to ${{ matrix.environment }} environment"
              terragrunt run-all apply -auto-approve -no-color -parallelism 2
            elif echo "${{ github.event.comment.body }}" | grep -q "^/digger apply$"; then
              echo "Deploying to ${{ matrix.environment }} environment (apply all)"
              terragrunt run-all apply -auto-approve -no-color -parallelism 2
            else
              echo "Planning for ${{ matrix.environment }} environment"
              terragrunt run-all plan -no-color -parallelism 4
            fi
          else
            echo "ğŸ“‹ Running plan for ${{ matrix.environment }} environment"
            terragrunt run-all plan -no-color -parallelism 4
          fi

      - name: Deployment Status Notification
        if: always()
        run: |
          if [ "${{ job.status }}" = "success" ]; then
            if [ "${{ github.event_name }}" = "push" ] && [ "${{ matrix.environment }}" = "dev" ]; then
              echo "âœ… Successfully auto-deployed to ${{ matrix.environment }} environment"
              echo "ğŸ¯ Resources deployed via merge to main branch"
            elif echo "${{ github.event.comment.body || '' }}" | grep -q "/digger apply"; then
              echo "âœ… Successfully deployed to ${{ matrix.environment }} environment"
              echo "ğŸ¯ Resources deployed via manual trigger"
            else
              echo "ğŸ“‹ Successfully planned ${{ matrix.environment }} environment"
              echo "ğŸ’¡ Use '/digger apply' comment to deploy or merge PR for auto-deploy (dev only)"
            fi
          else
            echo "âŒ Deployment failed for ${{ matrix.environment }} environment"
            echo "ğŸ”§ Check logs above for error details"
          fi

  generate-report:
    needs: detect-environments
    if: ${{ github.event_name == 'pull_request' }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
    steps:
      - uses: actions/checkout@v4

      - name: Generate Deployment Report
        run: |
          chmod +x scripts/generate-deployment-report.sh
          # Convert JSON array to comma-separated string for script
          ENVIRONMENTS_JSON='${{ needs.detect-environments.outputs.environments }}'
          ENVIRONMENTS_CSV=$(echo "$ENVIRONMENTS_JSON" | jq -r 'join(",")')
          ./scripts/generate-deployment-report.sh \
            "deployment-report.html" \
            "$ENVIRONMENTS_CSV" \
            "${{ github.event.pull_request.number }}" \
            "${{ github.sha }}"

      - name: Upload Deployment Report
        uses: actions/upload-artifact@v4
        with:
          name: deployment-report
          path: deployment-report.html
          retention-days: 30

      - name: Comment PR with Report Link
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Read the generated report to extract summary
            const reportExists = fs.existsSync('deployment-report.html');
            
            let comment = `## ğŸš€ Infrastructure Deployment Preview
            
            This PR will deploy the following infrastructure changes:
            
            **Environments:** \`${{ needs.detect-environments.outputs.environments }}\`
            **Generated:** ${new Date().toISOString()}
            
            ### ğŸ“‹ Deployment Strategy
            - **ğŸš§ Dev:** Auto-deploy on merge to main
            - **ğŸ­ Staging:** Manual deployment via \`/digger apply staging\`
            - **ğŸ”’ Prod:** Read-only (plans only)
            
            ### ğŸ“Š Detailed Report
            `;
            
            if (reportExists) {
              comment += `ğŸ“„ **[View Full Deployment Report](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})**
              
              The detailed HTML report shows:
              - Resource-by-resource deployment preview
              - Environment-specific deployment strategies  
              - Visual breakdown of infrastructure changes
              - Resource counts and action types
              
              *Download the \`deployment-report\` artifact from the Actions tab to view the full report.*`;
            } else {
              comment += `âš ï¸ Report generation failed. Check the [workflow logs](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}) for details.`;
            }
            
            comment += `
            
            ### ğŸ¯ Next Steps
            - **Review changes** in the detailed report above
            - **Test in dev** (optional): Comment \`/digger apply dev\`
            - **Merge PR** â†’ Auto-deploys to dev environment
            - **Deploy to staging** (after merge): Comment \`/digger apply staging\`
            
            ---
            *ğŸ¤– This report is automatically generated for all infrastructure PRs*`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });