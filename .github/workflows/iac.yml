name: iac
concurrency:
  group: iac-${{ github.ref }}
  cancel-in-progress: false
on:
  pull_request:
    paths: [ 'infra/live/**' ]
  issue_comment:
    types: [created]
jobs:
  digger:
    if: github.event_name == 'pull_request' || (github.event_name == 'issue_comment' && contains(github.event.comment.body, '/digger'))
    timeout-minutes: 60
    permissions:
      contents: read
      pull-requests: write
      issues: write
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Detect environment (dev/staging/prod)
        id: detect
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            BASE="origin/${{ github.base_ref }}"
            git fetch --quiet origin "${{ github.base_ref }}"
            CHANGED=$(git diff --name-only "$BASE"...HEAD | grep '^infra/live/' || true)
          else
            PRNUM="${{ github.event.issue.number }}"
            REPO="${{ github.repository }}"
            PAGE=1; CHANGED=""
            while :; do
              BATCH=$(curl -s -H "authorization: Bearer $GH_TOKEN" \
                "https://api.github.com/repos/${REPO}/pulls/${PRNUM}/files?per_page=100&page=${PAGE}" \
                | jq -r '.[].filename')
              [ -z "$BATCH" ] && break
              CHANGED=$(printf "%s\n%s" "$CHANGED" "$BATCH")
              PAGE=$((PAGE+1))
            done
            CHANGED=$(echo "$CHANGED" | grep '^infra/live/' || true)
          fi
          ENV="dev"
          echo "$CHANGED" | grep -q '/prod/' && ENV="prod"
          echo "$CHANGED" | grep -q '/staging/' && ENV="staging"
          echo "env=$ENV" >> $GITHUB_OUTPUT
          echo "$CHANGED"

      - name: Guard prod applies (prod is READ-ONLY)
        if: ${{ github.event_name == 'issue_comment' && contains(github.event.comment.body, '/digger apply') && steps.detect.outputs.env == 'prod' }}
        run: |
          echo 'Prod is READ-ONLY in this repo. /digger apply is blocked.' >&2
          exit 1

      - name: Select AWS credentials for env
        id: creds
        run: |
          case "${{ steps.detect.outputs.env }}" in
            dev) 
              echo "access_key_id=${{ secrets.AWS_ACCESS_KEY_ID_DEV }}" >> $GITHUB_OUTPUT
              echo "secret_access_key=${{ secrets.AWS_SECRET_ACCESS_KEY_DEV }}" >> $GITHUB_OUTPUT
              ;;
            staging) 
              echo "access_key_id=${{ secrets.AWS_ACCESS_KEY_ID_STAGING }}" >> $GITHUB_OUTPUT
              echo "secret_access_key=${{ secrets.AWS_SECRET_ACCESS_KEY_STAGING }}" >> $GITHUB_OUTPUT
              ;;
            prod) 
              echo "access_key_id=${{ secrets.AWS_ACCESS_KEY_ID_PROD }}" >> $GITHUB_OUTPUT
              echo "secret_access_key=${{ secrets.AWS_SECRET_ACCESS_KEY_PROD }}" >> $GITHUB_OUTPUT
              ;;
          esac

      - name: Env for non-interactive runs
        run: |
          echo "TF_IN_AUTOMATION=1" >> $GITHUB_ENV
          echo "TF_INPUT=0" >> $GITHUB_ENV

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ steps.creds.outputs.access_key_id }}
          aws-secret-access-key: ${{ steps.creds.outputs.secret_access_key }}
          aws-region: us-east-2

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.7.5

      - name: Install Terragrunt
        run: |
          TG_VERSION=v0.58.14
          curl -L https://github.com/gruntwork-io/terragrunt/releases/download/${TG_VERSION}/terragrunt_linux_amd64 \
            -o /usr/local/bin/terragrunt && chmod +x /usr/local/bin/terragrunt

      - name: Terragrunt Plan
        id: plan
        working-directory: infra/live
        run: |
          set -euo pipefail
          echo "## ğŸ—ï¸ Terraform Plan for ${{ steps.detect.outputs.env }} environment" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          terragrunt run-all plan -no-color -parallelism 4 2>&1 | tee plan.log
          
          # Format output for PR comment
          {
            echo "## ğŸ—ï¸ Terraform Plan for \`${{ steps.detect.outputs.env }}\` environment"
            echo ""
            echo "<details><summary>ğŸ“‹ Show Plan Output</summary>"
            echo ""
            echo '```'
            cat plan.log
            echo '```'
            echo "</details>"
            echo ""
            if [ "${{ steps.detect.outputs.env }}" = "prod" ]; then
              echo "âš ï¸ **Production is READ-ONLY** - Only plans and imports are allowed"
            else
              echo "âœ… To apply these changes, comment: \`/apply\`"
            fi
          } > plan_comment.md

      - name: Comment Plan on PR
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const comment = fs.readFileSync('infra/live/plan_comment.md', 'utf8');
            
            // Find existing plan comment to update
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
            });
            
            const existingComment = comments.find(comment => 
              comment.body.includes('ğŸ—ï¸ Terraform Plan for'));
            
            if (existingComment) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existingComment.id,
                body: comment
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: comment
              });
            }

      - name: Apply Changes
        if: github.event_name == 'issue_comment' && contains(github.event.comment.body, '/apply')
        working-directory: infra/live
        run: |
          echo "## ğŸš€ Applying Terraform Changes" >> $GITHUB_STEP_SUMMARY
          terragrunt run-all apply -auto-approve -no-color -parallelism 2 2>&1 | tee apply.log
          
          # Comment apply results
          {
            echo "## ğŸš€ Terraform Apply Results for \`${{ steps.detect.outputs.env }}\` environment"
            echo ""
            echo "<details><summary>ğŸ“‹ Show Apply Output</summary>"
            echo ""
            echo '```'
            cat apply.log
            echo '```'
            echo "</details>"
            echo ""
            echo "âœ… Changes have been applied successfully!"
          } > apply_comment.md

      - name: Comment Apply Results
        if: github.event_name == 'issue_comment' && contains(github.event.comment.body, '/apply')
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const comment = fs.readFileSync('infra/live/apply_comment.md', 'utf8');
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: comment
            });