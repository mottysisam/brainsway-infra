name: iac
concurrency:
  group: iac-${{ github.ref }}
  cancel-in-progress: false
on:
  pull_request:
    paths: [ 'infra/live/**' ]
  issue_comment:
    types: [created]
jobs:
  detect-environments:
    if: github.event_name == 'pull_request' || (github.event_name == 'issue_comment' && contains(github.event.comment.body, '/digger'))
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      environments: ${{ steps.detect.outputs.environments }}
    steps:
      - uses: actions/checkout@v4

      - name: Install jq
        run: sudo apt-get update && sudo apt-get install -y jq

      - name: Detect affected environments
        id: detect
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          if [ "${{ github.event_name }}" = "pull_request" ]; then
            # Use GitHub API for changed files to avoid merge base issues
            PRNUM="${{ github.event.pull_request.number }}"
            REPO="${{ github.repository }}"
            PAGE=1; CHANGED=""
            while :; do
              BATCH=$(curl -s -H "authorization: Bearer $GH_TOKEN" \
                "https://api.github.com/repos/${REPO}/pulls/${PRNUM}/files?per_page=100&page=${PAGE}" \
                | jq -r '.[].filename' 2>/dev/null || echo "")
              [ -z "$BATCH" ] && break
              CHANGED=$(printf "%s\n%s" "$CHANGED" "$BATCH")
              PAGE=$((PAGE+1))
            done
          else
            PRNUM="${{ github.event.issue.number }}"
            REPO="${{ github.repository }}"
            PAGE=1; CHANGED=""
            while :; do
              BATCH=$(curl -s -H "authorization: Bearer $GH_TOKEN" \
                "https://api.github.com/repos/${REPO}/pulls/${PRNUM}/files?per_page=100&page=${PAGE}" \
                | jq -r '.[].filename' 2>/dev/null || echo "")
              [ -z "$BATCH" ] && break
              CHANGED=$(printf "%s\n%s" "$CHANGED" "$BATCH")
              PAGE=$((PAGE+1))
            done
          fi
          
          # Filter for infra/live changes
          INFRA_CHANGED=$(echo "$CHANGED" | grep '^infra/live/' || echo "")
          
          # Detect ALL affected environments
          ENVIRONMENTS=""
          if echo "$INFRA_CHANGED" | grep -q '/dev/'; then
            ENVIRONMENTS="dev"
          fi
          if echo "$INFRA_CHANGED" | grep -q '/staging/'; then
            ENVIRONMENTS="${ENVIRONMENTS:+$ENVIRONMENTS,}staging"
          fi
          if echo "$INFRA_CHANGED" | grep -q '/prod/'; then
            ENVIRONMENTS="${ENVIRONMENTS:+$ENVIRONMENTS,}prod"
          fi
          
          # Default to dev if no environment detected (e.g., only root files changed)
          if [ -z "$ENVIRONMENTS" ] && [ -n "$INFRA_CHANGED" ]; then
            ENVIRONMENTS="dev"
          fi
          
          # Convert to JSON array for matrix
          if [ -n "$ENVIRONMENTS" ]; then
            # Create JSON array manually to avoid jq formatting issues
            ENV_LIST=$(echo "$ENVIRONMENTS" | tr ',' '\n' | sed 's/.*/"&"/' | tr '\n' ',' | sed 's/,$//')
            ENV_ARRAY="[$ENV_LIST]"
          else
            ENV_ARRAY='[]'
          fi
          
          echo "environments=$ENV_ARRAY" >> $GITHUB_OUTPUT
          echo "Changed infra files: $INFRA_CHANGED"
          echo "Affected environments: $ENVIRONMENTS"

  digger:
    needs: detect-environments
    if: ${{ needs.detect-environments.outputs.environments != '[]' }}
    timeout-minutes: 60
    permissions:
      contents: read
      pull-requests: write
      issues: write
      statuses: write
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        environment: ${{ fromJSON(needs.detect-environments.outputs.environments) }}
    steps:
      - uses: actions/checkout@v4

      - name: Guard prod applies (prod is READ-ONLY)
        if: ${{ github.event_name == 'issue_comment' && contains(github.event.comment.body, '/digger apply') && matrix.environment == 'prod' }}
        run: |
          echo 'Prod is READ-ONLY in this repo. /digger apply is blocked.' >&2
          exit 1

      - name: Select AWS credentials for ${{ matrix.environment }}
        id: creds
        run: |
          case "${{ matrix.environment }}" in
            dev) 
              echo "access_key_id=${{ secrets.AWS_ACCESS_KEY_ID_DEV }}" >> $GITHUB_OUTPUT
              echo "secret_access_key=${{ secrets.AWS_SECRET_ACCESS_KEY_DEV }}" >> $GITHUB_OUTPUT
              ;;
            staging) 
              echo "access_key_id=${{ secrets.AWS_ACCESS_KEY_ID_STAGING }}" >> $GITHUB_OUTPUT
              echo "secret_access_key=${{ secrets.AWS_SECRET_ACCESS_KEY_STAGING }}" >> $GITHUB_OUTPUT
              ;;
            prod) 
              echo "access_key_id=${{ secrets.AWS_ACCESS_KEY_ID_PROD }}" >> $GITHUB_OUTPUT
              echo "secret_access_key=${{ secrets.AWS_SECRET_ACCESS_KEY_PROD }}" >> $GITHUB_OUTPUT
              ;;
          esac

      - name: Env for non-interactive runs
        run: |
          echo "TF_IN_AUTOMATION=1" >> $GITHUB_ENV
          echo "TF_INPUT=0" >> $GITHUB_ENV

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ steps.creds.outputs.access_key_id }}
          aws-secret-access-key: ${{ steps.creds.outputs.secret_access_key }}
          aws-region: us-east-2

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.7.5

      - name: Install Terragrunt
        run: |
          TG_VERSION=v0.58.14
          curl -L https://github.com/gruntwork-io/terragrunt/releases/download/${TG_VERSION}/terragrunt_linux_amd64 \
            -o /usr/local/bin/terragrunt && chmod +x /usr/local/bin/terragrunt

      - name: Run Digger for ${{ matrix.environment }}
        uses: diggerhq/digger@v0.3.20
        with:
          no-backend: true
          setup-aws: false
          setup-terraform: false
          setup-terragrunt: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_CONTEXT: ${{ toJSON(github) }}
          DIGGER_PROJECT: ${{ matrix.environment }}